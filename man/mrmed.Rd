% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mrmed.R
\name{mrmed}
\alias{mrmed}
\title{Multiply robust (MR) estimator for total, natural direct and natural
indirect effects}
\usage{
mrmed(
  D,
  Y,
  M,
  D_C_model,
  D_MC_model = NULL,
  Y_DC_model = NULL,
  Y_DMC_model,
  M_DC_model = NULL,
  data,
  d = 1,
  dstar = 0,
  censor = TRUE,
  censor_low = 0.01,
  censor_high = 0.99,
  boot = TRUE,
  boot_reps = 2,
  boot_conf_level = 0.95,
  boot_seed = NULL,
  boot_parallel = FALSE,
  boot_cores = max(c(parallel::detectCores() - 2, 1))
)
}
\arguments{
\item{D}{A character scalar identifying the name of the exposure variable in
\code{data}. \code{D} is a character string, but the exposure variable it identifies
must be numeric and binary, with two distinct values.}

\item{Y}{A character scalar identifying the name of the outcome variable in
\code{data}. \code{Y} is a character string, but the outcome variable it identifies
must be numeric.}

\item{M}{A character vector (of one or more elements) identifying the names
of the mediator variables in \code{data}. If you are estimating univariate
natural effects (with a single mediator), \code{M} should be a character scalar
(i.e., a vector with only one element)—e.g., \code{M = "ever_unemp_age3539"}. If you
are estimating multivariate natural effects (with multiple mediators), \code{M}
should be a list identifying all mediators—e.g.,
\code{M = list("ever_unemp_age3539", "log_faminc_adj_age3539")}.}

\item{D_C_model}{A character scalar specifying the formula to be fitted for a
logit model of the exposure given baseline covariates (denoted in the book as
π(D|C)). This specification is required for both types of formula. E.g.,
\code{D_C_model = "att22 ~ female + black + hispan + paredu + parprof + parinc_prank + famsize + afqt3"}.}

\item{D_MC_model}{A character scalar specifying the formula to be fitted for a
logit model of the exposure given baseline covariates and the mediator(s)
(denoted in the book as π(D|C,M)). This specification is required only for
the Type 2 estimator. When this input is not NULL, the function will implement the Type 2
estimator by default and will throw an error if other models required for Type 2 estimation are
NULL. E.g.,
\code{D_MC_model = "att22 ~ female + black + hispan + paredu + parprof + parinc_prank + famsize + afqt3 + ever_unemp_age3539"}.}

\item{Y_DC_model}{A character scalar specifying the formula to be fitted for a
linear model of the conditional mean of μ(Y|C,M,D) given baseline covariates
and the treatment variable (denoted in the book as ν_D(C)). This specification
allows the user to specify interactions between D and C. In implementation,
the outcome variable is substituted with the estimated conditional mean from
the \code{Y_DMC_model}. This specification is required only for the Type 2 estimator.
When this input is not NULL, the function will implement the Type 2 estimator by
default and will throw an error if other models required for Type 2 estimation are
NULL. E.g.,
\code{Y_DC_model = "std_cesd_age40 ~ female + black + hispan + paredu + parprof + parinc_prank + famsize + afqt3 + att22"}.}

\item{Y_DMC_model}{A character scalar specifying the formula to be fitted for a
linear model of the outcome given baseline covariates, mediator(s), and the
treatment variable (denoted in the book as μ(Y|C,M,D)). This specification is
required for both types of estimator. E.g.,
\code{Y_DMC_model = "std_cesd_age40 ~ female + black + hispan + paredu + parprof + parinc_prank + famsize + afqt3 + att22 + ever_unemp_age3539"}.}

\item{M_DC_model}{A character scalar specifying the formula to be fitted for a
logit model of the conditional mean of P(M|C,D) given baseline covariates
and the treatment variable. This specification allows the user to specify
interactions between D and C, and is required only for Type 1 estimation.
When this input is not NULL, the function will implement the Type 1 estimator by default. E.g.,
\code{M_DC_model = "ever_unemp_age3539 ~ female + black + hispan + paredu + parprof + parinc_prank + famsize + afqt3 + att22"}.}

\item{data}{A data frame.}

\item{d}{The numeric value of the treatment variable that the user defines as
the treatment status. If not equal to 1, the function will recode it as 1.}

\item{dstar}{The numeric value of the treatment variable that the user defines
as the control status. If not equal to 0, the function will recode it as 0.}

\item{censor}{A logical scalar indicating whether the IPW weights constructed by
estimation should be censored. By default, this value is \code{TRUE}.}

\item{censor_low, censor_high}{A pair of arguments, each a numeric scalar
denoting a probability in \link{0,1}. If \code{censor} is TRUE, then IPW weights below
the \code{censor_low} quantile will be bottom-coded, and weights above the
\code{censor_high} quantile will be top-coded. E.g., if the default values
\code{censor_low = 0.01} and \code{censor_high = 0.99} are used, then IPW weights will
be censored at their 1st and 99th percentiles. By default, weights are censored
to the \link{1st, 99th} percentile range.}

\item{boot}{A logical scalar indicating whether the function should perform
the nonparametric bootstrap and return two-sided confidence intervals and
p-values.}

\item{boot_reps}{An integer scalar specifying the number of bootstrap replications
to perform.}

\item{boot_seed}{An integer scalar specifying the random-number seed used in
bootstrap resampling.}

\item{boot_parallel}{A logical scalar indicating whether the bootstrap should
be performed using a parallelized loop to reduce runtime. Parallel computation,
as implemented in this function, requires that the following R packages are installed:
\code{doParallel}, \code{doRNG}, and \code{foreach}. (However, you do not need to explicitly
load these packages using \code{library()}.) Note that the results of the parallelized
bootstrap may differ slightly from those of the non-parallelized bootstrap, even if
the same seed is specified, due to differences in how seeds are processed.}

\item{boot_cores}{An integer scalar specifying the number of CPU cores to use
for the parallelized bootstrap. This argument only affects computation if both
\code{boot} and \code{boot_parallel} are TRUE. By default, \code{boot_cores} is set to the greater
of two values: (a) one, and (b) the number of available CPU cores minus two.
If \code{boot_cores} equals one, the bootstrap loop will not be parallelized,
regardless of the value of \code{boot_parallel}.}

\item{boot_conf_lowevel}{A numeric scalar specifying the confidence level for the
bootstrap interval.}
}
\value{
Based on the user's specification, \code{mrmed()} returns a list with the
following elements:

\item{est1, est2}{A tibble containing the point estimates of \eqn{ATE(1,0)}, \eqn{NDE(1,0)},
and \eqn{NIE(1,0)}. When the user specifies all the nuisance functions for both the
Type 1 and Type 2 estimators, the function will return a list of estimated results for both;
otherwise, it will return a tibble named \code{est1} for Type 1 or \code{est2} for Type 2.}

\item{models_D}{A list of model objects from the fitted exposure models. For Type 1
estimation, this corresponds to the π(D|C) model (\code{D_C_model}); for Type 2,
this includes both the π(D|C,M) model (\code{D_MC_model}) and π(D|C) model (\code{D_C_model}).}

\item{models_M}{A model object from the fitted mediator model. This will only be returned
if the user specifies a model for the nuisance function \code{M_DC_model} for Type 1 estimation.}

\item{models_Y}{A list of model objects from the fitted outcome models.
For the Type 1 estimator, this includes μ(Y|C,M,D), corresponding to
\code{Y_DMC_model}. For the Type 2 estimator, it additionally includes
the ν_D(C) model under D = d and D = d*.}

If you request the bootstrap (by setting the \code{boot} argument to TRUE), the
function returns all of the elements listed above, as well as the
following additional elements:

\item{ci_ATE}{A numeric vector with the bootstrap confidence interval for the
total average treatment effect (ATE).}
\item{ci_NDE}{A numeric vector with the bootstrap confidence interval for the
natural direct effect (NDE).}
\item{ci_NIE}{A numeric vector with the bootstrap confidence interval for the
natural indirect effect (NIE).}
\item{pvalue_ATE}{A numeric scalar with the p-value from a two-sided test of
whether the ATE differs from zero, as computed from the bootstrap.}
\item{pvalue_NDE}{A numeric scalar with the p-value from a two-sided test of
whether the NDE differs from zero, as computed from the bootstrap.}
\item{pvalue_NIE}{A numeric scalar with the p-value from a two-sided test of
whether the NIE differs from zero, as computed from the bootstrap.}
\item{sd_ATE}{A numeric scalar with the standard error of the bootstrapped
ATE estimates.}
\item{sd_NDE}{A numeric scalar with the standard error of the bootstrapped
NDE estimates.}
\item{sd_NIE}{A numeric scalar with the standard error of the bootstrapped
NIE estimates.}
\item{method_type}{A vector indicating the method type returned. Can be \code{c(1)},
\code{c(2)}, or \code{c(1, 2)}.}
\item{boot_ATE}{A numeric vector of length \code{boot_reps} containing the ATE
estimates from all bootstrap replicate samples.}
\item{boot_NDE}{A numeric vector of length \code{boot_reps} containing the NDE
estimates from all bootstrap replicate samples.}
\item{boot_NIE}{A numeric vector of length \code{boot_reps} containing the NIE
estimates from all bootstrap replicate samples.}
}
\description{
\code{mrmed()} uses a multiply robust (MR) approach to estimate
the total effect (ATE), natural direct effect (NDE), and natural indirect
effect (NIE). The function supports estimation of both single mediator and
multiple mediator effects.
}
\details{
\code{mrmed()} performs causal mediation analysis using multiply robust estimation,
and computes inferential statistics using the nonparametric bootstrap. It will
estimate the effects using different formulas depending on the nuisance function
specifications.

For the Type 1 estimator (equation 6.17 in Wodtke and Zhou), \code{mrmed()} requires a logit model for P(M|D,C),
a logit model for P(D|C), and a linear model for E(Y|C,D,M).

For the Type 2 estimator (equation 6.20 in Wodtke and Zhou), it requires a logit model for P(D|C), another logit
model for P(D|C,M), a linear model for E(Y|C,M,D), and another linear model for E(E(Y|C,M,D=d)|C,D).

When analyzing multiple mediators simultaneously, users must employ the
Type 2 estimator, in which case \code{mrmed()} estimates multivariate natural
effects operating through the entire set of mediators.
}
\examples{
#----------------------------------------#
 Initial Specification and Clean the Data:
#----------------------------------------#
data(nlsy)
# outcome
Y <- "std_cesd_age40"

# exposure
D <- "att22"

# mediators
M <- list(
"ever_unemp_age3539",
"log_faminc_adj_age3539"
)
# baseline confounders:
C <- c(
"female",
"black",
"hispan",
"paredu",
"parprof",
"parinc_prank",
"famsize",
"afqt3"
)
# key variables
key_vars <- c(
 "cesd_age40", # unstandardized version of Y
  D,
  unlist(M),
  C
)

# Clean the Data:
df <-
nlsy[complete.cases(nlsy[,key_vars]),] |>
mutate(std_cesd_age40 = (cesd_age40 - mean(cesd_age40)) / sd(cesd_age40))

#-----------------------------------------#
 Specify the models:
#----------------------------------------#
# D Models:
1. Exposure ~ Baseline Confounders
  D_C_model <- as.formula(paste(D, " ~ ", paste(C, collapse= "+")))
2. Exposure ~ Baseline Confounders and Mediator
  D_MC_model <- as.formula(paste(D, " ~ ", paste(c(C, M[1]), collapse= "+")))
# Y Models:
1. Outcome ~ Baseline Confounders and Treatment
  Y_DC_model <- as.formula(paste(Y, " ~ ", paste(c(C, D), collapse= "+")))
2. Outcome ~ Baseline Confounders, Treatment and Mediator
  Y_DMC_model <- as.formula(paste(Y, " ~ ", paste(c(C, D, M[1]), collapse= "+")))

Example 1: Single Mediator:
#-----------------------------------------#
 Replicate Table 6-2 Col 3:
#----------------------------------------#
\dontrun{
mrmed_rst1 <-
  mrmed(
    D,
    Y,
    M[[1]],
    D_C_model,
    D_MC_model,
    Y_DC_model,
    Y_DMC_model,
    M_DC_model = NULL,
    data = df,
    d = 1,
    dstar = 0,
    censor = TRUE,
    censor_low = 0.01,
    censor_high = 0.99,
    boot = TRUE,
    boot_reps = 2000,
    boot_conf_level = 0.95,
    boot_seed = 02138,
    boot_parallel = FALSE,
  )
 }
}
